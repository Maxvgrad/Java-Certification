
--------------Working with Java Data Types----------------
You need to remember the following points about Boolean:

1. Boolean class has two constructors - Boolean(String) and Boolean(boolean)
The String constructor allocates a Boolean object representing the value true if the string argument is not null and is equal,
ignoring case, to the string "true". Otherwise, allocate a Boolean object representing the value false. 
Examples: new Boolean("True") produces a Boolean object that represents true. new Boolean("yes") produces a Boolean object that represents false.
The boolean constructor is self explanatory.

2. Boolean class has two static helper methods for creating booleans - parseBoolean and valueOf.
Boolean.parseBoolean(String ) method returns a primitive boolean and not a Boolean object 
(Note - Same is with the case with other parseXXX methods such as Integer.parseInt - they return primitives and not objects). 
The boolean returned represents the value true if the string argument is not null and is equal, ignoring case, to the string "true".

Boolean.valueOf(String ) and its overloaded Boolean.valueOf(boolean ) version, on the other hand, work similarly 
but return a reference to either Boolean.TRUE or Boolean.FALSE wrapper objects. 
Observe that they don't create a new Boolean object but just return the static constants TRUE or FALSE defined in Boolean class.

3. When you use the equality operator ( == ) with booleans, if exactly one of the operands is a Boolean wrapper, 
it is first unboxed into a boolean primitive and then the two are compared (JLS 15.21.2). 
If both are Boolean wrappers, then their references are compared just like in the case of other objects. 
Thus, new Boolean("true") == new Boolean("true") is false, but new Boolean("true") == Boolean.parseBoolean("true") is true.
--------------------------
Note: The following discussion about bit patterns and two's complement 
is not required for the exam but is useful for building the basic understanding.

It prints: -2147483648   -2147483648

This happens because negative integers are stored in 2's complement form (complement the bits and add 1). 
For example:

Integer 1 in binary is  00000000 00000000 00000000 00000001  (32 bits)

So -1 in binary would be (complement the bits for 1 and add 1) :

Step 1 (complement the bits of 1): 11111111 11111111 11111111 11111110  
Step 2 (add 1 to step 1): 11111111 11111111 11111111 11111111.

Now, let's see what happens in this question:

a = Integer.MIN_VALUE = 10000000 00000000 00000000 00000000

To get -a, apply the above two steps:

Step 1  (complement the bits): 01111111 11111111 11111111 11111111
Step 2 (add 1) : 10000000 00000000 00000000 00000000

So you got the exact same value that you started with!
(Note that you can see the binary form of an integer using Integer.toBinaryString(i) method.)




------------------Handling Exceptions------------------------
Observe that all the exceptions given in the options other than Exception and NoClassDefFoundError are RuntimeExceptions. 
These are usually thrown implicitly. A programmer should not throw these exceptions explicitly. java.lang.Exception 
and its subclasses (except RuntimeException) should be used by the programmer to reflect known exceptional situations, 
while RuntimeExceptions are used to reflect unforseen or unrecoverable exceptional situations.

Note: There is no hard and fast rule that says RuntimeExceptions (such as the ones mentioned in this questions)  must not be thrown explicitly. 
It is ok to throw these exceptions explicitly in certain situations. For example, framework/library classes such as Struts, Spring, and Hibernate, 
and standard JDK classes throw these exceptions explicitly. But for the purpose of the exam, 
it is a good way to determine if a given application should be thrown explicitly by the programmer or not.
------------------------
You must remember the hierarchy of exception classes:

The base class of all exceptions is java.lang.Throwable. java.lang.Error and java.lang.Exception are the only two subclasses of Throwable.

Error is used by the JVM to throw exception that have nothing to do with the program code as such but occur because of environment. 
For example, OutOfMemoryError. It indicates serious problems that a reasonable application should not try to catch. 
Most such errors are abnormal conditions. Error and its subclasses are regarded as unchecked exceptions for the purposes of compile-time checking of exceptions.

Exception is used by the programmer as well as the JVM when it encounters exceptional situation in the program. 
Exception and its subclasses (except RuntimeException) are called Checked Exceptions. 
Checked exceptions need to be declared in a method or constructor's throws clause if they can be thrown by the execution of the method 
or constructor and propagate outside the method or constructor boundary. For example, java.io.IOException.

RuntimeException extends Exception, which is used to report exceptional situations that cannot be predetermined at compile time. For example, 
IndexOutOfBoundsException or NullPointerException. RuntimeException and its subclasses are unchecked exceptions. 
Unchecked exceptions do not need to be declared in a method or constructor's throws clause.



------------------------Working with Inheritance-----------------------
The overriding method may opt not to declare any throws clause even if the original method has a throws clause.
No exception (i.e. an empty set of exceptions) is a valid subset of the set of exceptions thrown by the original method 
so an overriding method can choose to not have any throws clause.